<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multicolored Snake with Hot Dogs</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #003300;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: #ffffff;
    }

    #game-container {
      text-align: center;
    }

    h1 {
      margin-bottom: 10px;
    }

    #game-info {
      margin-bottom: 10px;
      font-size: 14px;
    }

    #gameCanvas {
      background-color: #003300;
      border: 2px solid #00aa00;
      box-shadow: 0 0 10px #00aa00;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <h1>Snake &amp; Hot Dogs</h1>
    <div id="game-info">
      Use arrow keys or WASD to move. Avoid the walls and yourself!
    </div>
    <canvas id="gameCanvas" width="500" height="500"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const gridSize = 20;      // 20x20 grid
    const cellSize = canvas.width / gridSize; // 25px if canvas is 500x500

    // Snake state
    let snake = [{ x: 10, y: 10 }];
    let direction = { x: 1, y: 0 };
    let nextDirection = { x: 1, y: 0 };
    let hotDogs = [];
    let gameOver = false;
    let speed = 120; // slightly slower

    const HOTDOG_COUNT = 14;  // 14 hot dogs on the grid

    const snakeColors = [
      "#ff4b5c",
      "#ffb400",
      "#3ae374",
      "#18dcff",
      "#7d5fff",
      "#ff9ff3"
    ];

    document.addEventListener("keydown", handleKey);

    function handleKey(e) {
      const key = e.key.toLowerCase();
      if (key === "arrowup" || key === "w") {
        if (direction.y === 0) nextDirection = { x: 0, y: -1 };
      } else if (key === "arrowdown" || key === "s") {
        if (direction.y === 0) nextDirection = { x: 0, y: 1 };
      } else if (key === "arrowleft" || key === "a") {
        if (direction.x === 0) nextDirection = { x: -1, y: 0 };
      } else if (key === "arrowright" || key === "d") {
        if (direction.x === 0) nextDirection = { x: 1, y: 0 };
      } else if (key === " " && gameOver) {
        resetGame();
      }
    }

    function resetGame() {
      snake = [{ x: 10, y: 10 }];
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      hotDogs = [];
      spawnInitialHotDogs();
      gameOver = false;
      loop();
    }

    function randomEmptyCell() {
      let pos;
      while (true) {
        pos = {
          x: Math.floor(Math.random() * gridSize),
          y: Math.floor(Math.random() * gridSize)
        };
        const onSnake = snake.some(seg => seg.x === pos.x && seg.y === pos.y);
        const onHotDog = hotDogs.some(h => h.x === pos.x && h.y === pos.y);
        if (!onSnake && !onHotDog) return pos;
      }
    }

    function spawnInitialHotDogs() {
      for (let i = 0; i < HOTDOG_COUNT; i++) {
        hotDogs.push(randomEmptyCell());
      }
    }

    function spawnSingleHotDog() {
      hotDogs.push(randomEmptyCell());
    }

    function update() {
      if (gameOver) return;

      direction = nextDirection;
      const head = snake[0];
      const newHead = {
        x: head.x + direction.x,
        y: head.y + direction.y
      };

      // Wall collision
      if (
        newHead.x < 0 ||
        newHead.x >= gridSize ||
        newHead.y < 0 ||
        newHead.y >= gridSize
      ) {
        gameOver = true;
        return;
      }

      // Self collision
      if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
        gameOver = true;
        return;
      }

      snake.unshift(newHead);

      // Check for hot dog collisions
      let ateHotDog = false;
      for (let i = 0; i < hotDogs.length; i++) {
        if (hotDogs[i].x === newHead.x && hotDogs[i].y === newHead.y) {
          hotDogs.splice(i, 1);
          ateHotDog = true;
          break;
        }
      }

      if (ateHotDog) {
        // Grow and respawn a new hot dog
        spawnSingleHotDog();
      } else {
        // Move without growing
        snake.pop();
      }
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#003300";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "#008800";
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridSize; i++) {
        const pos = i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(canvas.width, pos);
        ctx.stroke();
      }
    }

    function drawSnake() {
      for (let i = 0; i < snake.length; i++) {
        const seg = snake[i];
        const color = snakeColors[i % snakeColors.length];
        ctx.fillStyle = color;
        ctx.fillRect(
          seg.x * cellSize + 1,
          seg.y * cellSize + 1,
          cellSize - 2,
          cellSize - 2
        );
      }
    }

    function drawSingleHotDog(hotDog) {
      const x = hotDog.x * cellSize;
      const y = hotDog.y * cellSize;
      const padding = cellSize * 0.15;
      const hotDogWidth = cellSize - padding * 2;
      const hotDogHeight = cellSize * 0.5;

      // Bun
      ctx.fillStyle = "#ffcc66";
      const bunX = x + padding;
      const bunY = y + (cellSize - hotDogHeight) / 2;
      const radius = hotDogHeight / 2;

      ctx.beginPath();
      ctx.moveTo(bunX + radius, bunY);
      ctx.lineTo(bunX + hotDogWidth - radius, bunY);
      ctx.quadraticCurveTo(
        bunX + hotDogWidth,
        bunY,
        bunX + hotDogWidth,
        bunY + radius
      );
      ctx.lineTo(bunX + hotDogWidth, bunY + hotDogHeight - radius);
      ctx.quadraticCurveTo(
        bunX + hotDogWidth,
        bunY + hotDogHeight,
        bunX + hotDogWidth - radius,
        bunY + hotDogHeight
      );
      ctx.lineTo(bunX + radius, bunY + hotDogHeight);
      ctx.quadraticCurveTo(
        bunX,
        bunY + hotDogHeight,
        bunX,
        bunY + hotDogHeight - radius
      );
      ctx.lineTo(bunX, bunY + radius);
      ctx.quadraticCurveTo(bunX, bunY, bunX + radius, bunY);
      ctx.fill();

      // Sausage
      ctx.fillStyle = "#cc3300";
      const sausageHeight = hotDogHeight * 0.6;
      const sausageY = bunY + (hotDogHeight - sausageHeight) / 2;
      ctx.fillRect(
        bunX + radius / 2,
        sausageY,
        hotDogWidth - radius,
        sausageHeight
      );
    }

    function drawHotDogs() {
      hotDogs.forEach(h => drawSingleHotDog(h));
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#ffffff";
      ctx.textAlign = "center";
      ctx.font = "28px Arial";
      ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2 - 10);
      ctx.font = "18px Arial";
      ctx.fillText("Press Space to Restart", canvas.width / 2, canvas.height / 2 + 20);
    }

    function draw() {
      drawGrid();
      drawSnake();
      drawHotDogs();
      if (gameOver) {
        drawGameOver();
      }
    }

    function loop() {
      if (!gameOver) {
        update();
        draw();
        setTimeout(loop, speed);
      } else {
        draw();
        drawGameOver();
      }
    }

    // Start the game
    spawnInitialHotDogs();
    draw();
    loop();
  </script>
</body>
</html>
